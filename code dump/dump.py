modifiers_file = open(modifiers_filepath).read()  # open it
trait_file = open(modpath + "\\common\\traits\\tf_leader_opinion_autogenerated_traits.txt", 'w+')  # find the trait file or create one
if_block_file = open(modpath + "\\common\\scripted_effects\\tf_leader_opinion_autogenerated_effects.txt", 'w+')
loc_file = open(modpath + "\\localisation\\tf_leader_opinion_autogenerated__l_english.yml", 'w+', encoding='utf-8')

search_pattern_modifiers = re.compile(rf'^{mod_prefix}\w+', re.MULTILINE)  # extract the modifiers via regex
modifiers_list = re.findall(search_pattern_modifiers, modifiers_file)
search_pattern_modifiers_loc = re.compile(rf'"[^"]*"', re.MULTILINE)  # extract the modifier names via regex
modifiers_loc_list = re.findall(search_pattern_modifiers_loc, modifiers_file)
search_pattern_values = re.compile(r'-?[1-9]?[0-9]?[0-9]', re.MULTILINE)  # extract the modifier values via regex
values_list = map(int, re.findall(search_pattern_values, modifiers_file))


mod_val_dict = dictionary = dict(zip(modifiers_list, values_list))  # map them together in a dictionary
mod_loc_dict = dictionary = dict(zip(modifiers_list, modifiers_loc_list))


all_combinations = []  # initalize variables before the great loop
trait_code = ""
if_block_code = ""
loc_code_traits_positive = ""
loc_code_traits_negative = ""
loc_code_traits_positive_desc = ""
loc_code_traits_negative_desc = ""

if_block_code_1 = "tf_recalc_leader_opinion = {\n"  # define static parts of the code the loop generates
if_block_code_5 = "\n}\n"

for index, category in enumerate(mod_val_dict):  # use itertools to create a list of all possible modifier combinations
    combinations = map(dict, itertools.combinations(mod_val_dict.items(), index + 1))
    all_combinations.append(list(combinations))

for combination in all_combinations:  # iterate through the combinations
    for elements in combination:  # iterate through the elements of the combinations
        trait_name = '_'.join(elements.keys())  # extract the names of the "economic categories" add merge them together to form trait names
        modifiers = ('\t\t\t\t\t\t\t\t'+'\n\t\t\t\t\t\t\t\t'.join(f"{key}_opinion_produces_add = {value}" for key, value in elements.items()))  # generate the modifier names and add a bunch of tabs for nice formatting
        flags = ('has_leader_flag = '+'\n\t\t\t\thas_leader_flag = '.join(f"{key}" for key, value in elements.items()))  # generate the flags names used in the if block
        total_opinion_value = sum(elements.values())  # calculate the numeric value of the modifiers
        abs_opinion_value = abs(total_opinion_value)  # convert to an absolute value that can be used in the trait names
        if total_opinion_value > 0:
            prefix = "_plus_"  # trait names can't use +/- signs
            loc_code_traits_positive = loc_code_traits_positive + " " + trait_name + prefix + str(total_opinion_value) + ":0 " + f'''"This Leader's opinion of us: §G{total_opinion_value}§!"''' + '\n'  # assemble trait localisation for positive opinion traits
            loc_code_traits_positive_desc = loc_code_traits_positive_desc + " " + trait_name + prefix + str(total_opinion_value) + "_desc" + ":0 " + '''"This leader has a §Gpositive§! opinion about us."\n'''
        if total_opinion_value < 0:
            prefix = "_minus_"
            loc_code_traits_negative = loc_code_traits_negative + " " + trait_name + prefix + str(abs_opinion_value) + ":0 " + f'''"This Leader's opinion of us: §R{total_opinion_value}§!"''' + '\n'  # assemble trait localisation for negative opinion traits
            loc_code_traits_negative_desc = loc_code_traits_negative_desc + " " + trait_name + prefix + str(abs_opinion_value) + "_desc" + ":0 " + '''"This leader has a §Rnegative§! opinion of us."\n'''
        trait_code_1 = f'''{trait_name}{prefix}{abs_opinion_value} = {{
	                        cost = 0
	                        modification = no
	                        icon = "gfx/interface/icons/leader_opinion.dds"
	                        modifier = {{'''
        trait_code_2 = f'''	   \n{modifiers}                       
		                    }}
	                        leader_trait = all
	                        leader_class = {{ admiral scientist general governor envoy}}
                        }}'''  # merge everything together to form a complete trait

        if_block_code_2 = f'''if = {{
            limit = {{
                {flags}
            }}
            '''
        if_block_code_3 = f'''    set_variable = {{
                which = tf_leader_opinion
                value = {total_opinion_value}
            }}
            '''
        if_block_code_4 = f'''    add_trait = {trait_name}{prefix}{abs_opinion_value}
        }}
        '''  # merge everything together to form a complete if block

        if_block_code = if_block_code + if_block_code_2 + if_block_code_3 + if_block_code_4  # merge all the if blocks
        trait_code = trait_code + '\n' + '\n' + trait_code_1 + trait_code_2  # merge all the traits


if_block_code = if_block_code_1 + if_block_code + if_block_code_5  # merge the if blocks with the static code
loc_code_modifiers = ('\n'+' \n'.join(f" mod_{key}_opinion_produces_add:0 {value}" for key, value in mod_loc_dict.items()))

loc_code = "l_english:\n" + loc_code_modifiers + '\n' + '\n' + loc_code_traits_negative + '\n' + loc_code_traits_negative_desc + '\n' + loc_code_traits_positive + '\n' + loc_code_traits_positive_desc


trait_file.write(trait_code)  # write everything into the respective files
if_block_file.write(if_block_code)
loc_file.write(loc_code)

trait_file.close()  # close the files to avoid bugs
if_block_file.close()
loc_file.close()




def create_config():
    """Creates the configuration file"""  # ask the user for configuartion values
    cf_mod_prefix = input("Enter mod prefix: ")
    cf_vanilla_path = input("Enter path to vanilla game: ")
    cf_modpath = input("Enter path to mod files (The folder containing the common folder of the mod): ")
    cf_modifiers_path = input("Enter the path to the 'opinion modifer' economic categories file: ")
    cf_variables_path = input("Enter the path to the opinion variable file:")
    while True:
        cf_ethics = input("Automatically generate ethics opinion modifiers? (y/n)? ")  #Loop unitl a valid answer is given
        if cf_ethics == "y" or cf_ethics == "yes":
            cf_ethics_bool = True
            break  # exit the loop when a valid answer is given
        elif cf_ethics == "n" or cf_ethics == "no":
            cf_ethics_bool = False
            break
        else:
            print("Invalid input! Accepted values are 'yes', 'y', 'no' or 'n'.")

    config_parser["PREFIX"] = {  # map the answers to the config values
        "prefix": cf_mod_prefix
    }
    config_parser["PATHS"] = {
        "vanilla_path": cf_vanilla_path,
        "modpath": cf_modpath,
        "modifier_filepath": cf_modifiers_path,
        "variables_filepath": cf_variables_path,
    }

    config_parser["SETTINGS"] = {  # write values to config file
        "generate_ethics": cf_ethics_bool
    }

    with open('leader_system_config.ini', 'w') as conf:
        config_parser.write(conf)